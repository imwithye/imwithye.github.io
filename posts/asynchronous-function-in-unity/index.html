<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Asynchronous function in Unity | 禅心剑气相思骨</title><meta name=keywords content="Unity,Programming,C#"><meta name=description content="Async and await keyword Since Unity 2019, Unity introduces C# task and async/await keyword to MonoBehaviour. For Unity callback functions like Start, Update, now it supports the async version, and with the async keyword in the front, the function now will be dispatched asynchronously automatically by the engine.
private async void Start() { Debug.Log(&#34;Start task delay 2 seconds&#34;); await Task.Delay(TimeSpan.FromSeconds(2)); Debug.Log(&#34;Task delay 2 finished&#34;); } The function on the above will be executed and the first log shows immediately while the second log shows after 2 seconds."><meta name=author content="Yiwei Gong"><link rel=canonical href=https://yiwei.dev/posts/asynchronous-function-in-unity/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yiwei.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yiwei.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yiwei.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://yiwei.dev/apple-touch-icon.png><link rel=mask-icon href=https://yiwei.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Asynchronous function in Unity"><meta property="og:description" content="Async and await keyword Since Unity 2019, Unity introduces C# task and async/await keyword to MonoBehaviour. For Unity callback functions like Start, Update, now it supports the async version, and with the async keyword in the front, the function now will be dispatched asynchronously automatically by the engine.
private async void Start() { Debug.Log(&#34;Start task delay 2 seconds&#34;); await Task.Delay(TimeSpan.FromSeconds(2)); Debug.Log(&#34;Task delay 2 finished&#34;); } The function on the above will be executed and the first log shows immediately while the second log shows after 2 seconds."><meta property="og:type" content="article"><meta property="og:url" content="https://yiwei.dev/posts/asynchronous-function-in-unity/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-16T11:30:03+00:00"><meta property="article:modified_time" content="2020-11-16T11:30:03+00:00"><meta property="og:site_name" content="禅心剑气相思骨"><meta name=twitter:card content="summary"><meta name=twitter:title content="Asynchronous function in Unity"><meta name=twitter:description content="Async and await keyword Since Unity 2019, Unity introduces C# task and async/await keyword to MonoBehaviour. For Unity callback functions like Start, Update, now it supports the async version, and with the async keyword in the front, the function now will be dispatched asynchronously automatically by the engine.
private async void Start() { Debug.Log(&#34;Start task delay 2 seconds&#34;); await Task.Delay(TimeSpan.FromSeconds(2)); Debug.Log(&#34;Task delay 2 finished&#34;); } The function on the above will be executed and the first log shows immediately while the second log shows after 2 seconds."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yiwei.dev/posts/"},{"@type":"ListItem","position":3,"name":"Asynchronous function in Unity","item":"https://yiwei.dev/posts/asynchronous-function-in-unity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Asynchronous function in Unity","name":"Asynchronous function in Unity","description":"Async and await keyword Since Unity 2019, Unity introduces C# task and async/await keyword to MonoBehaviour. For Unity callback functions like Start, Update, now it supports the async version, and with the async keyword in the front, the function now will be dispatched asynchronously automatically by the engine.\nprivate async void Start() { Debug.Log(\u0026#34;Start task delay 2 seconds\u0026#34;); await Task.Delay(TimeSpan.FromSeconds(2)); Debug.Log(\u0026#34;Task delay 2 finished\u0026#34;); } The function on the above will be executed and the first log shows immediately while the second log shows after 2 seconds.","keywords":["Unity","Programming","C#"],"articleBody":"Async and await keyword Since Unity 2019, Unity introduces C# task and async/await keyword to MonoBehaviour. For Unity callback functions like Start, Update, now it supports the async version, and with the async keyword in the front, the function now will be dispatched asynchronously automatically by the engine.\nprivate async void Start() { Debug.Log(\"Start task delay 2 seconds\"); await Task.Delay(TimeSpan.FromSeconds(2)); Debug.Log(\"Task delay 2 finished\"); } The function on the above will be executed and the first log shows immediately while the second log shows after 2 seconds. The C# build-in HTTP library also provides a nice async wrapper, which can be used in the asynchronous MonoBehaviour as well.\nprivate async void Start() { var httpClient = new System.Net.Http.HttpClient(); var resp = await httpClient.GetAsync(\"https://google.com\"); Debug.Log(resp.StatusCode); } With the magic async keyboard, we can replace the Unity default coroutine, which is implemented by a yield generator with a much cleaner and nicer programming style.\nBackground task problem However, the async function, similar to JavaScript, is not executed in another thread. Instead, the function executes on the main thread, and only when the await keyword appears, the function executes may or MAY NOT on the main thread.\nprivate async void Start() { Log(\"Start\", \"Task delay 2 seconds\"); await Task.Delay(TimeSpan.FromSeconds(2)); Log(\"Start\", \"Task delay 2 finished\"); Log(\"Start\", \"Thread sleep 2 seconds\"); Thread.Sleep(TimeSpan.FromSeconds(2)); Log(\"Start\", \"Thread sleep done\"); } private void Update() { _frames++; } private void Log(string caller, string message) { Debug.Log($\"[Thread {Thread.CurrentThread.ManagedThreadId}][Frame {_frames}][Method {caller}] {message}\"); } Here we define a helper function Log to monitor the current thread and current frame count. The above function returns:\n1. [Thread 1][Frame 0][Method Start] Task delay 2 seconds 2. [Thread 1][Frame 172][Method Start] Task delay 2 finished 3. [Thread 1][Frame 172][Method Start] Thread sleep 2 seconds 4. [Thread 1][Frame 172][Method Start] Thread sleep done Notice the function does execute sequentially and asynchronously. Line 1 and line 2 shows the await keyword pushes the task to the background and resumes execution after 2 seconds as the frame count is different. However, line 3 and line 4 shows that the function runs still on the main thread, if there is a heavy computation task in the function, it blocks the whole system until it finishes.\nWorkaround Instead of lunching the task on the main thread, we can force it to lunch on a background thread and return a task to inform the main thread to await the result.\nprivate async void Start() { Log(\"Start\", \"Task delay 2 seconds\"); await Task.Delay(TimeSpan.FromSeconds(2)); Log(\"Start\", \"Task delay 2 finished\"); Log(\"Start\", \"Thread sleep 2 seconds\"); await Task.Run(() =\u003e Thread.Sleep(TimeSpan.FromSeconds(2))); Log(\"Start\", \"Thread sleep done\"); } Task.Run function will lunch the lambda action on the background thread. Instead of blocking the execution of the main thread, the main thread Start function will pause here and await the Task.Run function to finish. Then it resumes afterward. The above function returns:\n1. [Thread 1][Frame 0][Method Start] Task delay 2 seconds 2. [Thread 1][Frame 167][Method Start] Task delay 2 finished 3. [Thread 1][Frame 167][Method Start] Thread sleep 2 seconds 4. [Thread 1][Frame 378][Method Start] Thread sleep done However, this is not perfect. Task.Run keyword requires the code wrapped into a function, which breaks the sequential code flow and makes the language more verbose. Secondly, it does now work with the Unity coroutine magic keywords, such as WaitForEndOfFrame. UniTask solves these issues in an elegant and efficient way!\nUniTask (UniTask)[https://github.com/Cysharp/UniTask] is written by Yoshifumi Kawai, a Japanese developer and Microsoft MVP for Visual C# since 2011. UniTask aims for providing an efficient allocation free async/await integration to Unity, and PlayerLoop based task(UniTask.Yield, UniTask.Delay, UniTask.DelayFrame, etc.) that enable to replace all coroutine operation. UniTask provides a plug-and-play replacement for C# default Task library and Unity default coroutine. For example,\nprivate IEnumerator\u003cobject\u003e CoroutineSleep() { Log(\"Coroutine\", \"Coroutin sleep 2 seconds\"); yield return new WaitForSeconds(2); Log(\"Coroutine\", \"Coroutin sleep done\"); } The code above can be easily converted into UniTask’s version\nprivate async UniTask UniTaskSleep() { Log(\"Coroutine\", \"UniTask sleep 2 seconds\"); await UniTask.Delay(TimeSpan.FromSeconds(2)); Log(\"Coroutine\", \"UniTask sleep done\"); } UniTask provides PlayerLoop based tasks, for example, await UniTask.WaitForEndOfFrame();, await UniTask.NextFrame(); so that you can apply them just like in the coroutine context.\nBackground task in UniTask Not only a nicer replacement for Unity coroutine, UniTask also provides a nicer background thread management. With special task SwitchToThreadPool, UniTask allows the thread changes current context to a thread pool thread and execute on the background.\nprivate async void Start() { Log(\"Start\", \"Task delay 2 seconds\"); await UniTask.Delay(TimeSpan.FromSeconds(2)); Log(\"Start\", \"Task delay 2 finished\"); Log(\"Start\", \"Thread sleep 2 seconds\"); await UniTask.SwitchToThreadPool(); Log(\"Start\", \"Going to sleep\"); Thread.Sleep(TimeSpan.FromSeconds(2)); await UniTask.SwitchToMainThread(); Log(\"Start\", \"Thread sleep done\"); } The result of above function\n1. [Thread 1][Frame 0][Method Start] Task delay 2 seconds 2. [Thread 1][Frame 167][Method Start] Task delay 2 finished 3. [Thread 1][Frame 167][Method Start] Thread sleep 2 seconds 4. [Thread 68][Frame 168][Method Start] Going to sleep 5. [Thread 1][Frame 287][Method Start] Thread sleep done UniTask will push the current execution context to the thread pool after UniTask.SwitchToThreadPool() and switch back to main thread after UniTask.SwitchToMainThread(). UniTask also provides a handy tool, UniTask Tracker to monitor the task usage in the Unity Editor.\n","wordCount":"848","inLanguage":"en","datePublished":"2020-11-16T11:30:03Z","dateModified":"2020-11-16T11:30:03Z","author":{"@type":"Person","name":"Yiwei Gong"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yiwei.dev/posts/asynchronous-function-in-unity/"},"publisher":{"@type":"Organization","name":"禅心剑气相思骨","logo":{"@type":"ImageObject","url":"https://yiwei.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yiwei.dev accesskey=h title="禅心剑气相思骨 (Alt + H)">禅心剑气相思骨</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Asynchronous function in Unity</h1><div class=post-meta><span title='2020-11-16 11:30:03 +0000 UTC'>November 16, 2020</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;848 words&nbsp;·&nbsp;Yiwei Gong</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#async-and-await-keyword aria-label="Async and await keyword">Async and await keyword</a></li><li><a href=#background-task-problem aria-label="Background task problem">Background task problem</a></li><li><a href=#workaround aria-label=Workaround>Workaround</a></li><li><a href=#unitask aria-label=UniTask>UniTask</a></li><li><a href=#background-task-in-unitask aria-label="Background task in UniTask">Background task in UniTask</a></li></ul></div></details></div><div class=post-content><h2 id=async-and-await-keyword>Async and await keyword<a hidden class=anchor aria-hidden=true href=#async-and-await-keyword>#</a></h2><p>Since Unity 2019, Unity introduces C# task and async/await keyword to MonoBehaviour. For Unity callback functions like <code>Start</code>, <code>Update</code>, now it supports the async version, and with the <code>async</code> keyword in the front, the function now will be dispatched asynchronously automatically by the engine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;Start task delay 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> Task.Delay(TimeSpan.FromSeconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>&#34;Task delay 2 finished&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The function on the above will be executed and the first log shows immediately while the second log shows after 2 seconds.
The C# build-in HTTP library also provides a nice async wrapper, which can be used in the asynchronous MonoBehaviour as well.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> httpClient = <span style=color:#66d9ef>new</span> System.Net.Http.HttpClient();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> resp = <span style=color:#66d9ef>await</span> httpClient.GetAsync(<span style=color:#e6db74>&#34;https://google.com&#34;</span>);
</span></span><span style=display:flex><span>    Debug.Log(resp.StatusCode);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With the magic <code>async</code> keyboard, we can replace the Unity default coroutine, which is implemented by a <code>yield</code> generator with a much cleaner and nicer programming style.</p><h2 id=background-task-problem>Background task problem<a hidden class=anchor aria-hidden=true href=#background-task-problem>#</a></h2><p>However, the async function, similar to JavaScript, is not executed in another thread. Instead, the function executes on the main thread, and only when the await keyword appears, the function executes may or <strong>MAY NOT</strong> on the main thread.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Task delay 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> Task.Delay(TimeSpan.FromSeconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Task delay 2 finished&#34;</span>);
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Thread sleep 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    Thread.Sleep(TimeSpan.FromSeconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Thread sleep done&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _frames++;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Log(<span style=color:#66d9ef>string</span> caller, <span style=color:#66d9ef>string</span> message)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Debug.Log(<span style=color:#e6db74>$&#34;[Thread {Thread.CurrentThread.ManagedThreadId}][Frame {_frames}][Method {caller}] {message}&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we define a helper function Log to monitor the current thread and current frame count. The above function returns:</p><pre tabindex=0><code>1. [Thread 1][Frame 0][Method Start] Task delay 2 seconds
2. [Thread 1][Frame 172][Method Start] Task delay 2 finished
3. [Thread 1][Frame 172][Method Start] Thread sleep 2 seconds
4. [Thread 1][Frame 172][Method Start] Thread sleep done
</code></pre><p>Notice the function does execute sequentially and asynchronously. Line 1 and line 2 shows the await keyword pushes the task to the background and resumes execution after 2 seconds as the frame count is different. However, line 3 and line 4 shows that the function runs still on the main thread, if there is a heavy computation task in the function, it blocks the whole system until it finishes.</p><h2 id=workaround>Workaround<a hidden class=anchor aria-hidden=true href=#workaround>#</a></h2><p>Instead of lunching the task on the main thread, we can force it to lunch on a background thread and return a task to inform the main thread to await the result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Task delay 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> Task.Delay(TimeSpan.FromSeconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Task delay 2 finished&#34;</span>);
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Thread sleep 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> Task.Run(() =&gt; Thread.Sleep(TimeSpan.FromSeconds(<span style=color:#ae81ff>2</span>)));
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Thread sleep done&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>Task.Run</code> function will lunch the lambda action on the background thread. Instead of blocking the execution of the main thread, the main thread Start function will pause here and await the <code>Task.Run</code> function to finish. Then it resumes afterward. The above function returns:</p><pre tabindex=0><code>1. [Thread 1][Frame 0][Method Start] Task delay 2 seconds
2. [Thread 1][Frame 167][Method Start] Task delay 2 finished
3. [Thread 1][Frame 167][Method Start] Thread sleep 2 seconds
4. [Thread 1][Frame 378][Method Start] Thread sleep done
</code></pre><p>However, this is not perfect. Task.Run keyword requires the code wrapped into a function, which breaks the sequential code flow and makes the language more verbose. Secondly, it does now work with the Unity coroutine magic keywords, such as <code>WaitForEndOfFrame</code>.
<strong>UniTask</strong> solves these issues in an elegant and efficient way!</p><hr><h2 id=unitask>UniTask<a hidden class=anchor aria-hidden=true href=#unitask>#</a></h2><p>(UniTask)[https://github.com/Cysharp/UniTask] is written by Yoshifumi Kawai, a Japanese developer and Microsoft MVP for Visual C# since 2011. UniTask aims for providing an efficient allocation free async/await integration to Unity, and PlayerLoop based task(<code>UniTask.Yield</code>, <code>UniTask.Delay</code>, <code>UniTask.DelayFrame</code>, etc.) that enable to replace all coroutine operation.
UniTask provides a plug-and-play replacement for C# default Task library and Unity default coroutine. For example,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> IEnumerator&lt;<span style=color:#66d9ef>object</span>&gt; CoroutineSleep()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Coroutine&#34;</span>, <span style=color:#e6db74>&#34;Coroutin sleep 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> WaitForSeconds(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Coroutine&#34;</span>, <span style=color:#e6db74>&#34;Coroutin sleep done&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The code above can be easily converted into UniTask’s version</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> UniTask UniTaskSleep()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Coroutine&#34;</span>, <span style=color:#e6db74>&#34;UniTask sleep 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> UniTask.Delay(TimeSpan.FromSeconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Coroutine&#34;</span>, <span style=color:#e6db74>&#34;UniTask sleep done&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>UniTask provides PlayerLoop based tasks, for example, <code>await UniTask.WaitForEndOfFrame()</code>;, <code>await UniTask.NextFrame()</code>; so that you can apply them just like in the coroutine context.</p><h2 id=background-task-in-unitask>Background task in UniTask<a hidden class=anchor aria-hidden=true href=#background-task-in-unitask>#</a></h2><p>Not only a nicer replacement for Unity coroutine, UniTask also provides a nicer background thread management. With special task SwitchToThreadPool, UniTask allows the thread changes current context to a thread pool thread and execute on the background.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Task delay 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> UniTask.Delay(TimeSpan.FromSeconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Task delay 2 finished&#34;</span>);
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Thread sleep 2 seconds&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> UniTask.SwitchToThreadPool();
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Going to sleep&#34;</span>);
</span></span><span style=display:flex><span>    Thread.Sleep(TimeSpan.FromSeconds(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> UniTask.SwitchToMainThread();
</span></span><span style=display:flex><span>    Log(<span style=color:#e6db74>&#34;Start&#34;</span>, <span style=color:#e6db74>&#34;Thread sleep done&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The result of above function</p><pre tabindex=0><code>1. [Thread 1][Frame 0][Method Start] Task delay 2 seconds
2. [Thread 1][Frame 167][Method Start] Task delay 2 finished
3. [Thread 1][Frame 167][Method Start] Thread sleep 2 seconds
4. [Thread 68][Frame 168][Method Start] Going to sleep
5. [Thread 1][Frame 287][Method Start] Thread sleep done
</code></pre><p>UniTask will push the current execution context to the thread pool after <code>UniTask.SwitchToThreadPool()</code> and switch back to main thread after <code>UniTask.SwitchToMainThread()</code>.
UniTask also provides a handy tool, UniTask Tracker to monitor the task usage in the Unity Editor.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yiwei.dev/tags/unity/>Unity</a></li><li><a href=https://yiwei.dev/tags/programming/>Programming</a></li><li><a href=https://yiwei.dev/tags/c#/>C#</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yiwei.dev>禅心剑气相思骨</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>